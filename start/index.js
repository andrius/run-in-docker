const core = require("@actions/core");
const exec = require("@actions/exec");
const { isContainerRunning, execInDocker } = require("../utils/docker");
const path = require("path");

/**
 *  Function that starts the Docker container and executes commands inside it.
 * @returns {Promise<void>} A promise that resolves when the execution is complete.
 */
async function start() {
  try {
    const image = core.getInput("image");
    const workdir = core.getInput("workdir");
    const customOptions = core.getInput("custom_options");
    const commands = core.getInput("run");
    // containerName is optional
    let containerName = core.getInput("container_name");
    const containerNameArgs = !containerName ? '' : `--name ${containerName}`;

    const homeDir = path.resolve(process.env.HOME); // Home directory of the GitHub runner
    const runnerTemp = path.resolve(process.env.RUNNER_TEMP); // Temp directory of the GitHub runner
    const githubWorkspace = path.resolve(process.env.GITHUB_WORKSPACE);
    const githubOutput = path.resolve(process.env.GITHUB_OUTPUT);
    const githubEnv = path.resolve(process.env.GITHUB_ENV);
    const githubStepSummary = path.resolve(process.env.GITHUB_STEP_SUMMARY);

    // checks to avoid double mounting the same directory
    const volumeMapping =
      githubWorkspace === workdir
        ? `-v ${workdir}:${workdir}`
        : `-v ${githubWorkspace}:${githubWorkspace} -v ${workdir}:${workdir}`;

    const runCommand = `
      docker run ${customOptions || ""} -q -d ${containerNameArgs} \
      --add-host host.docker.internal:host-gateway --add-host host-gateway:host-gateway \
      -w ${workdir} ${volumeMapping} \
      -v ${homeDir}:${homeDir} \
      -v ${runnerTemp}:${runnerTemp} \
      -v ${githubOutput}:${githubOutput} \
      -v ${githubEnv}:${githubEnv} \
      -v ${githubStepSummary}:${githubStepSummary} \
      ${image} sleep infinity
    `.trim();
    // console.log(runCommand);

    // Capture stdout (the container name) and stderr (if any error occurs)
    const options = {};
    let cmdOutput = "";
    let cmdError = "";
    options.listeners = {
      stdout: (data) => {
        cmdOutput += data.toString();
      },
      stderr: (data) => {
        cmdError += data.toString();
      },
    };
    // Start the container
    const exitCode = await exec.exec(runCommand, [], options);
    if (exitCode != 0) {
      throw new Error(cmdError);
    }

    if (containerName === "") {
      // If no container name was provided, use the one generated by Docker
      containerName = cmdOutput.trim();
    }
    // save the container name to the GitHub step output and state (for the cleanup)
    core.setOutput("container_name", containerName);
    core.saveState("container_name", containerName);

    if (commands) {
      await execInDocker(containerName, workdir, commands);
    } else {
      core.setOutput("status", "success");
    }
  } catch (error) {
    core.setFailed(`Action failed with error ${error}`);
    core.setOutput("status", "failure");
  }
}

start();
